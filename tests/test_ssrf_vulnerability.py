import unittest
from unittest.mock import patch, MagicMock
import socket
import requests
from security_utils import is_safe_url, safe_requests_get

class TestSSRFRedirect(unittest.TestCase):
    def test_is_safe_url_allows_initial_safe_url(self):
        # safe.com resolves to public IP
        with patch('socket.getaddrinfo') as mock_getaddrinfo:
            mock_getaddrinfo.return_value = [(socket.AF_INET, socket.SOCK_STREAM, 6, '', ('8.8.8.8', 80))]
            self.assertTrue(is_safe_url('http://safe.com'))

    def test_safe_requests_get_blocks_redirect_to_unsafe(self):
        # safe_requests_get should manually handle redirects and check each one.
        # If it encounters an unsafe redirect, it should raise ValueError.

        with patch('requests.get') as mock_get:
            mock_response_302 = requests.Response()
            mock_response_302.status_code = 302
            mock_response_302.headers['Location'] = 'http://localhost'
            # We need to simulate close call too
            mock_response_302.close = MagicMock()

            # This is what safe_requests_get calls
            mock_get.return_value = mock_response_302

            with self.assertRaises(ValueError) as cm:
                safe_requests_get('http://safe.com')

            self.assertIn("Unsafe URL detected", str(cm.exception))
            self.assertIn("localhost", str(cm.exception))

if __name__ == '__main__':
    unittest.main()
